
пагинация для таблицы
windowing для таблицы?
сделать sql запросы # отменено # что же сделать вместо?
пофиксить когда едит и жмеш он отменяется сделать тоаст
сделать тоаст на тайлвинде
сделать блоб # ладна неважна или важна)
сделать продление кукесов на вебсокетах

и проект полностью готов! всего 7 задач осталось до окончания сего чуда инженерной мысли

сделана)
держать в памяти все данные для итерации по ним если где-то есть unique либо парсить ответ сервера (что более логичнее)
кнопка чтобы узнать схему таблицы ! Сделано за примерно 2 часа
парсить результат после запроса на создание если там автоинкремент гдета # тока если етот автоинкремент нулл)
redesign



  // const handleEditRow = async (rowIndex) => {
  //   let isNull = false;
  //   let autoincrement_index = null;
  //   let nullIndex = null;
  //   let cantnull_indices = [];
  //   let unique_indices = [];
  //   let isDataValid = true;
  
  //   if (rowIndex === editableRowIndex) {
  //     const oldData = data[rowIndex];
  //     let updatedData = [...data];
  
  //     columns.forEach((column, index) => {
  //       if (column.unique || column.pk) {
  //         unique_indices.push(index);
  //       }
  //       if (column.autoincrement) {
  //         autoincrement_index = index;
  //       }
  //       if (column.notnull) {
  //         cantnull_indices.push(index);
  //       }
  //     });
  
  //     editedData.forEach((value, index) => {
  //       let column = columns[index];
  //       if (column.notnull && (value == "" || (column.type == "INTEGER" && value == "-"))) {
  //         isNull = true;
  //         nullIndex = index;
  //         toast.error(`${column.name} не может быть пустой`);
  //       }
  //     });
  
  //     if (isNull) {
  //       return;
  //     }
  
  //     const updatedRowData = updatedData[rowIndex];
  //     updatedData[rowIndex] = editedData;

  //     console.log(updatedData)
  //     console.log(rowIndex)
  //     console.log(editedData)
  //     console.log(updatedRowData)

  //     if (newRowIndex === rowIndex) {
  //       try {
  //         const res = await createTableRow(tableName, editedData, columns);
  //         if (autoincrement_index !== null) {
  //           updatedData = res.data;
  //         }
  //       } catch (err) {
  //         toast.error(err.response.data.detail);
  //         isDataValid = false;
  //       }
  //     } else {
  //       try {
  //         await updateTableData(tableName, editedData, oldData, columns);
  //       } catch (err) {
  //         toast.error(err.response.data.detail);
  //         isDataValid = false;
  //       }
  //     }
  //     if (!isDataValid) {
  //       console.log(updatedData)
  //       // setEditableRowIndex(null);
  //       // setEditedData([]);
  //       // setNewRowIndex(null);
  //       return;
  //     }
  
  //     setEditableRowIndex(null);
  //     setEditedData([]);
  //     setNewRowIndex(null);
  //     setData(updatedData);
  //     console.log(data);
  //   } else {
  //     setEditableRowIndex(rowIndex);
  //     setEditedData(data[rowIndex]);
  //   }
  // };